<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>SapeAOB, _Andai&#39; puro sapeando mi c√≥digo oe!_ :: Sebasti√°n Aedo&#39;s blog ‚Äî Aventuras de un estudiante cualquiera.</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Finalmente era hora, era hora de retomar la pr√°ctica con C&#43;&#43; porque, why not? Rust para mi sigue siendo el lenguaje que m√°s prefiero, pero C&#43;&#43; est√° dentro de las categor√≠as de los lenguajes que tambi√©n disfruto. Pero para volver a tomarlo en serio, era necesario crear un proyecto nuevo, y as√≠ surgi√≥ sapeAOB, (una mezcla entre sapeao&#39; y AOB - Array of Bytes), una microlibrer√≠a que permite encontrar patrones de bytes escrita en C&#43;&#43;17."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://etra0.github.io/posts/2021-08-07-sapeando-tu-codigo/" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108274078-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-108274078-4');
</script>



<link rel="stylesheet" href="https://etra0.github.io/assets/style.css">


<link rel="stylesheet" href="https://etra0.github.io/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://etra0.github.io/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="https://etra0.github.io/img/favicon.png">


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="SapeAOB, _Andai&#39; puro sapeando mi c√≥digo oe!_"/>
<meta name="twitter:description" content="Finalmente era hora, era hora de retomar la pr√°ctica con C&#43;&#43; porque, why not? Rust para mi sigue siendo el lenguaje que m√°s prefiero, pero C&#43;&#43; est√° dentro de las categor√≠as de los lenguajes que tambi√©n disfruto. Pero para volver a tomarlo en serio, era necesario crear un proyecto nuevo, y as√≠ surgi√≥ sapeAOB, (una mezcla entre sapeao&#39; y AOB - Array of Bytes), una microlibrer√≠a que permite encontrar patrones de bytes escrita en C&#43;&#43;17."/>



<meta property="og:title" content="SapeAOB, _Andai&#39; puro sapeando mi c√≥digo oe!_" />
<meta property="og:description" content="Finalmente era hora, era hora de retomar la pr√°ctica con C&#43;&#43; porque, why not? Rust para mi sigue siendo el lenguaje que m√°s prefiero, pero C&#43;&#43; est√° dentro de las categor√≠as de los lenguajes que tambi√©n disfruto. Pero para volver a tomarlo en serio, era necesario crear un proyecto nuevo, y as√≠ surgi√≥ sapeAOB, (una mezcla entre sapeao&#39; y AOB - Array of Bytes), una microlibrer√≠a que permite encontrar patrones de bytes escrita en C&#43;&#43;17." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://etra0.github.io/posts/2021-08-07-sapeando-tu-codigo/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-07T16:00:00-03:00" />
<meta property="article:modified_time" content="2021-08-07T16:00:00-03:00" /><meta property="og:site_name" content="Sebasti√°n Aedo&#39;s blog" />







  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">Sebasti√°n Aedo&#39;s blog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title"><a href="https://etra0.github.io/posts/2021-08-07-sapeando-tu-codigo/">SapeAOB, <em>Andai' puro sapeando mi c√≥digo oe!</em></a></h1>
    <div class="post-meta">
      
        <span class="post-date">
          2021-08-07
        </span>

        
          
        
      

      
      
    </div>

    
      <span class="post-tags">
        
          #<a href="https://etra0.github.io/tags/c&#43;&#43;/">c&#43;&#43;</a>&nbsp;
        
          #<a href="https://etra0.github.io/tags/performance/">performance</a>&nbsp;
        
          #<a href="https://etra0.github.io/tags/x86-assembly/">x86 assembly</a>&nbsp;
        
          #<a href="https://etra0.github.io/tags/re/">re</a>&nbsp;
        
      </span>
    

    
      
        <img src="https://etra0.github.io/assets/images/sapeaob/logo.png" class="post-cover" />
      
    

    <div class="post-content">
      
      <p>Finalmente era hora, era hora de retomar la pr√°ctica con C++ porque, <em>why
not?</em> Rust para mi sigue siendo el lenguaje que m√°s prefiero, pero C++ est√°
dentro de las categor√≠as de los lenguajes que tambi√©n disfruto. Pero para
volver a tomarlo en serio, era necesario crear un proyecto nuevo, y as√≠
surgi√≥ <a href="https://github.com/etra0/sapeaob">sapeAOB</a>, (una mezcla entre <em>sapeao'</em> y AOB - Array of Bytes), una
microlibrer√≠a que permite encontrar patrones de bytes escrita en C++17.</p>
<h1 id="first-and-foremost-modern-c-is-nothing-like-uni-c">First and foremost: Modern C++ is nothing like Uni C++</h1>
<p>Primero que todo, es <strong>necesario</strong> sacarse de la cabeza que C++ es <em>&ldquo;C con
clases&rdquo;</em>. Quiz√°s esto fue cierto hace un tiempo (probablemente en sus inicios),
pero este lenguaje ha mutado demasiado (para bien o para mal) comparado con C,
y estoy casi seguro que cualquier persona que siga creyendo tal aseveraci√≥n,
al segundo que vea un extracto de C++17 o posterior, se dar√° cuenta de esto
tambi√©n, porque existen <strong>un mont√≥n de tecnolog√≠as nuevas</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">it</span>, std<span style="color:#f92672">::</span>size_t... Indexes<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span>
compare_(it arr, std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Indexes...<span style="color:#f92672">&gt;</span>) <span style="color:#66d9ef">noexcept</span> {
    <span style="color:#66d9ef">return</span> (... <span style="color:#f92672">&amp;&amp;</span> compare_one_(arr, Indexes, Pattern));
}
</code></pre></div><div style="text-align: center;">
		<em>I mean look at this shit, does this looks like C to you?</em>
</div>

<p>Un par de profesores de la U <em>pecaron</em> diciendo esto al introducir el lenguaje
al ramo, pero est√° bien, quiz√°s no es su deber estar al d√≠a cuando ese no es el
enfoque del curso <del>(en mi opini√≥n si lo es pero who cares)</del>.</p>
<h2 id="pero-qu√©-tiene-de-distinto-a-c-aparte-de-sus-clases">Pero, ¬øqu√© tiene de distinto a C, aparte de sus clases?</h2>
<p>Bueno, un mont√≥n, tantas que en un blogpost ser√≠a imposible enumerarlas. Al
menos, lo que not√© en mi estad√≠a universitaria, principalmente se usaba C++99,
<strong>el cual a estas alturas es m√°s de 20 a√±os viejo</strong>. En la actualidad, a√∫n se
ocupan bastante los punteros, pero el enfoque ha sido en intentar alejarse un
poco del <code>new</code> y el <code>delete</code>, siendo emplazados por el enfoque
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>
usando estructuras tales como <code>std::unique_ptr&lt;T&gt;</code> o <code>std::shared_ptr&lt;T&gt;</code>, que
facilitan mucho el manejo de memoria y evita cometer grandes errores usando
contadores de referencia. Tambi√©n hay muchas adiciones como iteradores,
<code>templates</code>, etc. Tantas que nisiquiera intentar√© referenciarlas, pero te
invito a darle una oportunidad nueva a este lenguaje si es que te interesa el
performance, y <a href="https://cppreference.com">cppreference</a> es un gran sitio para
comenzar.</p>
<h2 id="ya-pero-y-en-qu√©-afecta-esto-al-boca-o-a-sapeaob">Ya pero, ¬øY en qu√© afecta esto al Boca (o a SapeAOB)?</h2>
<p>Probablemente existan muchas librer√≠as que se enfocan en buscar ciertos valores
contiguos en un array, pero mi enfoque en particular estaba en funciones
generadas a tiempo de compilaci√≥n, de lo cu√°l hablaremos ahora.</p>
<h1 id="rust--c-vs-the-interpreted-world">Rust &amp; C++ vs. the interpreted world</h1>
<p>Lenguajes interpretados, a estas alturas has escuchado mucho de √©stos, quiz√°s
no categorizados como tal, pero en el campo laboral son los lenguajes que m√°s
frecuentemente encuentras: Python, Javascript, Java (kinda), Shellscript
(bash), etc. Todos estos lenguajes tienen una similitud, y es que existe un
software que se encarga de procesar el c√≥digo que uno escribe e interpretarlo
al mismo tiempo, y sin la existencia de este software el c√≥digo &ldquo;por si solo&rdquo;
no podr√≠a funcionar.</p>
<p>No hay nada malo en esto, esto ha permitido que el multiplataforma sea una
garant√≠a a estas alturas, son en general mucho m√°s f√°ciles y r√°pido de iterar y
son super c√≥modos, pero tienen 2 problemas esenciales que afectan en escenarios
muy espec√≠ficos: como ya se mencion√≥, dependen del software que los interpreta
y por lo tanto la segunda, al tener una capa extra (y grande) de abstracci√≥n,
son m√°s lentos.</p>
<p>Comenzar una holy war de que tipo de lenguaje es mejor tampoco es mi intenci√≥n,
soy un fiel creyente de que cada lenguaje tiene su utilidad <em>(Use the right
tool for the job)</em>. Me encanta hacer
an√°lisis de datos en Python, y tambi√©n me encanta escribir software bajo nivel
en Rust, ¬øPor qu√© no podr√≠a disfrutar de ambos?</p>
<h2 id="entonces-por-qu√©-estamos-hablando-de-√©sto">Entonces, ¬øpor qu√© estamos hablando de √©sto?</h2>
<p>Bueno, como ya se mencion√≥ dos veces, estos lenguajes interpretados requieren
de un software que los interprete, y por lo tanto, a grandes rasgos, tienen una
sola fase: Runtime, o tiempo de ejecuci√≥n. Es decir, este programa s√≥lo existe
cuando el int√©rprete lo <em>interpreta</em> valga la redundancia. Generalmente estos
lenguajes son muy din√°micos, permiten hacer cosas muy locas con la manipulaci√≥n
de objetos para incrementar sus habilidades a Runtime, y por lo menos en mi
mente, me hac√≠a pensar <strong>que solo existe una fase en la etapa de
programaci√≥n</strong>, lo cual es muy relevante para el t√≥pico siguiente.</p>
<h2 id="compile-time-escribiendo-los-bytes-que-tu-cpu-va-a-leer">Compile time, escribiendo los bytes que tu CPU va a leer.</h2>
<p>C, C++, Rust, Go son algunos de los lenguajes que se me vienen a la cabeza.
Estos son lenguajes <strong>compilados</strong>. ¬øQu√© quiere decir esto? Bueno, que para que
tu computador pueda ejecutarlos, despu√©s de que t√∫ como programador termine de
escribirlo, tienen que pasar por un proceso de <em>traducci√≥n</em>, este proceso es el
que se llama <strong>compilar</strong> (Bieeeen a grandes rasgos, hay muchos detalles que
no valen la pena escribirlos ac√°). ¬øEn qu√© consiste este proceso? Bueno,
primero el <strong>compilador</strong> lee tu c√≥digo, lo convierte a un formato que √©l
entienda (s√≠, el c√≥digo es para que los humanos lo entiendan, no tu
computador), y luego genera el c√≥digo ensamblado que es el que finalmente leer√°
tu computador para ser ejecutado. Una vez tu compilaste tu programa, se obtiene
lo que se llama un <em>binario</em>, que es b√°sicamente a lo que tu haces doble click
para abrir un programa. Este <em>binario</em>, contiene toda la informaci√≥n necesaria
para que tu sistema operativo y tu CPU pueda ejecutarlo, es decir, <strong>no
depende de un tercer software para poder ejecutarlo (no es interpretado)</strong> y por
lo tanto posee dos fases: Compilaci√≥n y Ejecuci√≥n (Runtime). Es
m√°s, es aqu√≠ donde se pone interesante y la raz√≥n por la cu√°l SapeAOB fue escrito
(<em>mansa' intro</em>).</p>
<h1 id="sapeando-tu-c√≥digo">Sapeando tu c√≥digo.</h1>
<p>Los binarios contienen toda la informaci√≥n necesaria para ser ejecutados, y por
lo tanto, no necesitas mantener el c√≥digo fuente para ejecutar el programa a
diferencia de los lenguajes interpretados. (<strong>pero si lo quieres seguir
mejorando, obvio que lo necesitar√°s lol</strong>).</p>
<p>Estos binarios pueden ser &ldquo;desensamblados&rdquo; de tal forma que puedas
leer su <em>c√≥digo</em>, pero a diferencia del c√≥digo fuente, solo tendr√°s acceso a lo
que el compilador escribi√≥ por ti, el cual corresponde al lenguaje
<strong>assembly</strong>. Por lo menos, yo recuerdo que en la Universidad nos
met√≠an mucho miedo sobre este lenguaje, que necesitabas ser un verdadero <em>pro</em>
para poder escribir en √©l, y prob√°blemente sea cierto si es que quieres
escribir un programa desde cero (lo cu√°l es bastante poco pr√°ctico hoy en
d√≠a a no ser que quieras extraer hasta la √∫ltima gota de performance que puedas
desde tu CPU, lo cual no solo requiere conocer el lenguaje si no que las
capacidades espec√≠ficas de tu procesador), pero para leerlo e interpretarlo no
necesitas ser un real <em>pro</em>, solo necesitas estudiarlo un poco (y para escribir
shellcodes tambi√©n).</p>
<p>El objetivo de SapeAOB es encontrar un patr√≥n de bytes en un arreglo. Los
binarios pueden ser le√≠dos como un mont√≥n de bytes (que a la vez contiene
las instrucciones necesarias para ser ejecutado). Cuando hacemos modificaciones
a los binarios, estos en general se hacen a un conjunto de instrucciones
espec√≠ficas (por ejemplo, que deje de decrementar la vida del jugador). Estas
instrucciones se pueden ir moviendo cada vez que compilamos nuevamente el
programa original y por lo tanto, sus offsets var√≠an. Es por esto que es mejor
usar patrones de bytes (informalmente array of bytes) para encontrar estas
instrucciones espec√≠ficas independiente de los futuros cambios que se hagan en
otras secciones del c√≥digo (y por eso, sapeamos el c√≥digo üòÖ).</p>
<p>En el contexto del game hacking, como mencion√© en un
<a href="https://etra0.github.io/posts/2020-12-06-memory-rs-internal/#haciendo-todo-update-proof-scan_aob">blogpost</a>
pasado, es importante tener la habilidad de usar
AoB&rsquo;s para que las inyecciones sean update-proof.</p>
<h2 id="detalles-de-la-implementaci√≥n">Detalles de la implementaci√≥n.</h2>
<p>Hasta ahora hemos hablado mucho sobre el contexto y poco sobre la intenci√≥n y
la forma en la que est√° escrita SapeAOB. Como se mencion√≥ en la secci√≥n donde
se defin√≠an los lenguajes interpretados, los lenguajes compilados poseen 2
fases esenciales durante su vida: Fase de compilaci√≥n, y fase de ejecuci√≥n.
Como en la actualidad estamos mucho m√°s acostumbrado a los lenguajes
intepretados que a los lenguajes compilados, como ya mencion√©, cuesta pensar en
estas dos fases como algo separado, por lo menos en mi cabeza el proceso de
&ldquo;compilar&rdquo; tu software era una tarea m√°s que un proceso por s√≠ solo.</p>
<h2 id="the-fun-stuff-generating-code-at-compile-time">The fun stuff: Generating code at compile time</h2>
<p>Los <code>templates</code> llevan bastante tiempo en C++, cada vez que usabas algo como
<code>std::vector&lt;int&gt;</code> estabas usando un template donde el tipo que reemplazabas
eras <code>int</code>. ¬øQu√© significaba esto para el compilador? Bueno, cuando tu escribes
una funci√≥n que usa templates, lo que le indicas al compilador es que por cada
aparici√≥n de un tipo nuevo que ocupa esta clase, funci√≥n o estructura, debe
generar el c√≥digo espec√≠fico para ser usado por ese tipo. Todo este c√≥digo se
genera en el tiempo de compilaci√≥n y una de las grandes ventajas es que permite
al compilador usar optimizaciones espec√≠ficas para cada tipo de forma m√°s
inteligente.</p>
<h3 id="ejemplo">Ejemplo</h3>

  <img src="/assets/images/sapeaob/disassembly.png"  class="left"  />


<p>Bear with me, el c√≥digo generado no es complejo. Si te fijas en el lado derecho
existen 3 funciones (o labels), <code>main</code> que corresponde de forma hom√≥loga a la
del c√≥digo de la izquierda, <code>unsigned short sum_one(unsigned short)</code> y otra
<code>unsigned int sum_one(unsigned int)</code>. Como te puedes fijar, el compilador cre√≥
<strong>2</strong> funciones <code>sum_one</code> en vez de una como nosotros escribimos. Fij√°ndonos en
lo esencial, en main primero se hace un <code>mov</code> al registro (algo as√≠ como
variable) <code>edi</code> del valor 1 y luego se llama a la versi√≥n <code>unsigned short</code>, y
como se puede apreciar en la funci√≥n en s√≠, se guarda un entero de tama√±o 2 con
la operaci√≥n <code>mov word ptr [rbp - 2], ax</code>, ya que <code>word</code> corresponde a variables
de tama√±o 2, en cambio en la de <code>unsigned int</code>, se utiliza <code>mov dword ptr [rbp - 4], edi</code>, donde <code>dword</code> corresponde a una variable de tama√±o 4. Es decir, el
compilador gener√≥ c√≥digo espec√≠fico para cada uno de los tipos por nosotros lo
que *en general* genera un mejor rendimiento. Esto es el equivalente a que
nosotros hubi√©semos escrito ambas versiones a mano en C.</p>
<h2 id="back-to-the-details">Back to the details.</h2>
<p>Sabiendo sobre estas fases de compilaci√≥n, y como funcionan <strong>a nivel bien
b√°sico</strong> los templates, es que comenc√© a escribir SapeAOB. Durante el
desarrollo segu√≠ dos approach:</p>
<ul>
<li>Corta fuego</li>
<li>Bitwise operations</li>
</ul>
<p>La versi√≥n cortafuegos b√°sicamente consist√≠a en una larga concatenaci√≥n de <code>&amp;&amp;</code>
para verificar que un arreglo siguiera un patr√≥n. Por ejemplo, si tenemos el
patr√≥n <code>0xAA, 0xBB, 0xCC</code>, lo que hac√≠a era generar un &ldquo;if&rdquo; bien largo que se
escribe como <code>if (arr[offset] == 0xAA &amp;&amp; arr[offset+1] == 0xBB &amp;&amp; arr[offset+2] == 0xCC)</code>. La gran ventaja de este approach, es que al igual que en varios
lenguajes, este tipo de <code>&amp;&amp;</code> concatenados generan un &ldquo;cortafuegos&rdquo;, en el
sentido de que a penas uno sea falso, se corta la verificaci√≥n de todo el
resto.</p>
<p>El otro approach, fue generando operaciones binarias usando <code>xor</code> y <code>and</code>. Los
detalles no son tan importantes, pero b√°sicamente se verificaba que al hacer
<code>xor</code> estos bits se anularan y si es que era 0, significaba que son iguales.</p>
<p>En un principio pens√© que hacer este cambio provocar√≠a mejoras, pero sucedi√≥ lo
contrario. Desde mi perspectiva creo que esto provocaba un peor rendimiento
debido a que s√≠ o s√≠ verificaba todo el patr√≥n antes de decidir si era
realmente un match o no, a diferencia del primer approach que simplemente
cortaba la verificaci√≥n a penas el primer byte distinto se identificara.</p>
<p>
  <img src="/assets/images/sapeaob/logical-bitwise.png"  class="left"  />


<div style="text-align: center;">
		<em>Disassembly de los dos distintos m√©todos en un patr√≥n espec√≠fico. Como se
puede apreciar en el primero, en el caso de que sea falso, saltaba
inmediatamente al final del c√≥digo (jne = jump if not equal), en cambio en el
otro caso, no existe ning√∫n jump mas que el del final.</em>
</div>
</p>
<p>Habiendo escrito la funci√≥n esencial encargada de ser generada a tiempo de
compilaci√≥n, despu√©s bast√≥ con generar la capa de abstracci√≥n que finalmente
ocupar√° el usuario al hacer uso de esta librer√≠a. Todo este estudio, para
finalmente escribir algo tan simple como:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span><span style="color:#66d9ef">uint8_t</span> test_arr2[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0xCC</span>, <span style="color:#ae81ff">0xFF</span>, <span style="color:#ae81ff">0xAA</span>, <span style="color:#ae81ff">0xEE</span>, <span style="color:#ae81ff">0xCC</span>};
sapeaob<span style="color:#f92672">::</span>pattern<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0xAA</span>, sapeaob<span style="color:#f92672">::</span>ANY, <span style="color:#ae81ff">0xCC</span><span style="color:#f92672">&gt;</span> p{};
result <span style="color:#f92672">=</span> p.scan_match(test_arr2, <span style="color:#66d9ef">sizeof</span>(test_arr2));
CHECK(result <span style="color:#f92672">==</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>uintptr_t<span style="color:#f92672">&gt;</span>(test_arr2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>));
</code></pre></div><div style="text-align: center;">
		<em><code>sapeaob::ANY</code> corresponde a la keyword que actua como wildcard, es decir, el
segundo byte puede ser cualquier byte.</em>
</div>

<p>Como se puede apreciar en el ejemplo, el constructor de <code>sapeaob::pattern</code> no
recibe ning√∫n par√°metro en s√≠, estos par√°metros son pasados a trav√©s de la
especificaci√≥n del <code>template</code>, por lo que esta informaci√≥n es guardada <strong>a
tiempo de compilaci√≥n</strong>, y por lo tanto las funciones para comparar el arreglo
con un patr√≥n son generadas por t√≠. <em>Pretty nice huh?</em>.</p>
<h1 id="oye-y-vali√≥-la-pena-experimentar-con-esto">Oye y, ¬øvali√≥ la pena experimentar con esto?</h1>
<p>Pero por supuesto! Siempre hay una buena raz√≥n para aprender de algo, hacer
experimentos y profundizar conocimientos. Adem√°s, result√≥ que <code>sapeaob</code> es
<a href="https://github.com/etra0/sapeaob-bench">bastante r√°pido!</a></p>
<p><a href="https://twitter.com/FransBouma">Frans Bouma</a>, un conocido modder de freecameras (al
cual respeto mucho) fue lo suficientemente amable como para prestarme su
implementaci√≥n para as√≠ poder hacer benchmarks. Adem√°s, tambi√©n lo compar√© con
la librer√≠a open source de <a href="https://twitter.com/__silent_">Silent</a> &mdash; <em>un
conocido modder de la escena de GTA que ha hecho importantes parches</em> &mdash;
<a href="https://github.com/CookiePLMonster/ModUtils/">ModUtils</a> y resulta que sapeAOB
es m√°s r√°pida en la mayor√≠a de los casos comparados con estas librer√≠as!</p>

  <img src="/assets/images/sapeaob/benchmark.png"  class="left"  />


<p>En fin, este post fue bastante extenso y bastante t√©cnico, pero espero que como
lector hayas podido llegar hasta el final, y si no, no importa, tambi√©n me
gusta escribir estos posts para mi mismo, quiz√°s en el futuro lo leer√©
nuevamente y me re-encantar√© con la programaci√≥n una vez m√°s.</p>

    </div>
    


    
      
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">Sebasti√°n Aedo&#39;s blog</span>
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span>¬© 2021 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span>
        <span>Theme created by <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="https://etra0.github.io/assets/main.js"></script>
<script src="https://etra0.github.io/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
