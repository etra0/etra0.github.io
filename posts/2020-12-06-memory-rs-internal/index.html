<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>memory-rs: going internal &amp; Yakuza Like A Dragon Photo Mode :: Sebasti√°n Aedo&#39;s blog ‚Äî Aventuras de un estudiante cualquiera.</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Habiendo comenzado a experimentar con hacking interno a trav√©s de inyecci√≥n de DLLs, y mientras esperaba la salida del juego Yakuza: Like A Dragon, aprovech√© de comenzar a preparar mi librer√≠a memory-rs para por fin comenzar a utilizar hacking interno, que por lo general conllevaba m√°s trabajo preparar el boilerplate pero al final tra√≠a muchos m√°s beneficios.
Evoluci√≥n de memory-rs A partir del 27 de octubre, comenc√© a trabajar casi todos los d√≠as en esta librer√≠a, porque cada vez me fascinaba m√°s las posibles t√©cnicas que se pueden utilizar al estar dentro del mismo espacio de memoria que el proceso objetivo, por lo que era necesario construir un toolkit para evitar ser redundante en futuras ocasiones."/>
<meta name="keywords" content=""/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="https://etra0.github.io/posts/2020-12-06-memory-rs-internal/" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-108274078-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-108274078-4');
</script>



<link rel="stylesheet" href="https://etra0.github.io/assets/style.css">


<link rel="stylesheet" href="https://etra0.github.io/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://etra0.github.io/img/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="https://etra0.github.io/img/favicon.png">


<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="memory-rs: going internal &amp; Yakuza Like A Dragon Photo Mode"/>
<meta name="twitter:description" content="Habiendo comenzado a experimentar con hacking interno a trav√©s de inyecci√≥n de DLLs, y mientras esperaba la salida del juego Yakuza: Like A Dragon, aprovech√© de comenzar a preparar mi librer√≠a memory-rs para por fin comenzar a utilizar hacking interno, que por lo general conllevaba m√°s trabajo preparar el boilerplate pero al final tra√≠a muchos m√°s beneficios.
Evoluci√≥n de memory-rs A partir del 27 de octubre, comenc√© a trabajar casi todos los d√≠as en esta librer√≠a, porque cada vez me fascinaba m√°s las posibles t√©cnicas que se pueden utilizar al estar dentro del mismo espacio de memoria que el proceso objetivo, por lo que era necesario construir un toolkit para evitar ser redundante en futuras ocasiones."/>



<meta property="og:title" content="memory-rs: going internal &amp; Yakuza Like A Dragon Photo Mode" />
<meta property="og:description" content="Habiendo comenzado a experimentar con hacking interno a trav√©s de inyecci√≥n de DLLs, y mientras esperaba la salida del juego Yakuza: Like A Dragon, aprovech√© de comenzar a preparar mi librer√≠a memory-rs para por fin comenzar a utilizar hacking interno, que por lo general conllevaba m√°s trabajo preparar el boilerplate pero al final tra√≠a muchos m√°s beneficios.
Evoluci√≥n de memory-rs A partir del 27 de octubre, comenc√© a trabajar casi todos los d√≠as en esta librer√≠a, porque cada vez me fascinaba m√°s las posibles t√©cnicas que se pueden utilizar al estar dentro del mismo espacio de memoria que el proceso objetivo, por lo que era necesario construir un toolkit para evitar ser redundante en futuras ocasiones." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://etra0.github.io/posts/2020-12-06-memory-rs-internal/" />
<meta property="article:published_time" content="2020-12-06T23:19:23-03:00" />
<meta property="article:modified_time" content="2020-12-06T23:19:23-03:00" /><meta property="og:site_name" content="Sebasti√°n Aedo&#39;s blog" />






  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">Sebasti√°n Aedo&#39;s blog</span>
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
      <span class="theme-toggle">
        <svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title"><a href="https://etra0.github.io/posts/2020-12-06-memory-rs-internal/">memory-rs: going internal &amp; Yakuza Like A Dragon Photo Mode</a></h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-12-06
        </span>

        
          
        
      

      
      
    </div>

    
      <span class="post-tags">
        
          #<a href="https://etra0.github.io/tags/rust/">rust</a>&nbsp;
        
          #<a href="https://etra0.github.io/tags/assembly/">assembly</a>&nbsp;
        
          #<a href="https://etra0.github.io/tags/re/">re</a>&nbsp;
        
      </span>
    

    
      
        <img src="https://etra0.github.io/assets/images/memory-rs/cover.png" class="post-cover" />
      
    

    <div class="post-content">
      
      <p>Habiendo comenzado a experimentar con hacking interno  a trav√©s de inyecci√≥n de
DLLs, y mientras esperaba la salida del juego <em>Yakuza: Like A Dragon</em>,
aprovech√© de comenzar a preparar mi librer√≠a <code>memory-rs</code> para por fin comenzar
a utilizar hacking interno, que por lo general conllevaba m√°s trabajo preparar
el boilerplate pero al final tra√≠a muchos m√°s beneficios.</p>
<h1 id="evoluci√≥n-de-_memory-rs_">Evoluci√≥n de <em>memory-rs</em></h1>
<p><a href="https://github.com/etra0/memory-rs/commit/d9c9521907bd9bb5ce35447b12a27830e8dbf9d1">A partir del 27 de
octubre</a>,
comenc√© a trabajar casi todos los d√≠as en esta librer√≠a, porque cada vez me
fascinaba m√°s las posibles t√©cnicas que se pueden utilizar al estar dentro
del mismo espacio de memoria que el proceso objetivo, por lo que era necesario
construir un toolkit para evitar ser redundante en futuras ocasiones.</p>
<p>El objetivo final de esta librer√≠a es facilitar la edici√≥n de memoria, que
sirva para juegos es una consecuencia secundaria, pero en el estado actual,
√©sta permite f√°cilmente inyectar <code>shellcodes</code> o hacer function detouring,
t√©cnicas que se usan frecuentemente para expandir APIs privadas o en su
defecto, a veces para desarrollar malware bastante b√°sico.</p>
<p>Despu√©s de haber experimentado con distintas necesidades de modificaci√≥n de
memoria, conclu√≠ que era necesario implementar 3 estructuras esenciales que
facilitan la modificaci√≥n de software closed source para expandir su
funcionalidad.</p>
<h2 id="detour-injection--staticelement">Detour, Injection &amp; StaticElement</h2>
<p>Estas 3 estructuras son las que defino como esencial para facilitar el game
modding. Quiz√°s despu√©s agregar√© m√°s (o quiz√°s elimine alguna), pero por ahora,
esta separaci√≥n me ha funcionado bastante bien. Aqu√≠ un breve resumen de qu√© es
lo que hace cada una:</p>
<ul>
<li><strong>Detour</strong>: Estructura que contiene un puntero a una parte original del
c√≥digo, un puntero a una funci√≥n que se va a inyectar y opcionalmente un
puntero a donde debe volver (en el caso de lo que se inyecte sea un
shellcode, usualmente se salta de vuelta a donde estaba el c√≥digo
originalmente).</li>
<li><strong>Injection</strong>: Estructura que contiene un puntero a una parte original del
c√≥digo, y un vector que contiene los bytes que se sobreescribir√°n sobre esa
funci√≥n original. √âsta estructura es √∫til cuando se necesitan nopear
instrucciones o cuando se necesitan cambiar  de <code>jmp</code>s condicionales (<code>ja</code>,
<code>jb</code>, <code>je</code>, etc) a <code>jmp</code></li>
<li><strong>StaticElement</strong>: Estructura que contiene un puntero a una direcci√≥n
est√°tica, y un valor, y este se sobreescribe cada vez que se llame a la
funci√≥n <code>inject</code>.</li>
</ul>
<p>Lo interesante de estas 3 estructuras, es que fueron pensadas usando la
estrategia
<a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a>,
por lo que al sacar la inyecci√≥n, todo queda limpio como si nada hubiese pasado
(ya sea porque se va fuera del scope o porque se saca el DLL).</p>
<h2 id="haciendo-todo-update-proof-scan_aob">Haciendo todo update-proof: scan_aob</h2>
<p>Una de las grandes ventajas de usar hacking interno, es que se tiene acceso
completo a la memoria del proceso (obviamente, los segmentos que son v√°lidos,
<em>duh</em>). Previamente, cuando necesitaba modificar algo haciendo todo externo,
deb√≠a solicitar a trav√©s de una syscall a Windows que me entregue una copia de
bytes del espacio de memoria que deseo leer. Ahora, simplemente todo se
transforma en √°lgebra de punteros, lo cu√°l acelera bastante el proceso de
obtenci√≥n de datos ya que no hay intermediario.</p>
<p>Sabiendo esto, ahora era vital implementar una funci√≥n que hace mucho tiempo
quer√≠a hacer, debido a que me permitir√° hacer parches update-proof: <code>scan_aob</code>.
La gracia de dicha funci√≥n, es que a partir de un patr√≥n de bytes, te permite
buscar dentro de segmentos de memoria (usualmente, escaneo el binario del
ejecutable) y cuando se haga match del patr√≥n, se retorna la direcci√≥n.
Esto es √∫til porque por ejemplo, cuando se actualiza un juego, los offsets
suelen cambiar al hacer la recompilaci√≥n, porque basta que una estructura tenga
un campo nuevo o que quiz√°s un string sea un par de bytes m√°s largo, y el
parche ya no funcionar√°. Esto facilita bastante las cosas y adem√°s permite
compatibilidad entre versiones (La freecam de Yakuza Like A Dragon funciona
para Steam y para Microsoft Store sin hacer cambio alguno gracias a esto!).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// snip
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> store_pref_detour <span style="color:#f92672">=</span> <span style="color:#66d9ef">unsafe</span> {
	<span style="color:#66d9ef">let</span> (size, func) <span style="color:#f92672">=</span> generate_aob_pattern<span style="color:#f92672">!</span>[
		<span style="color:#ae81ff">0x8B</span>, <span style="color:#ae81ff">0x41</span>, _, <span style="color:#ae81ff">0x89</span>, _, <span style="color:#ae81ff">0x8B</span>, <span style="color:#ae81ff">0x41</span>, <span style="color:#ae81ff">0x24</span>, <span style="color:#ae81ff">0x41</span>, <span style="color:#ae81ff">0x89</span>, <span style="color:#ae81ff">0x00</span>, <span style="color:#ae81ff">0xC3</span>
	];
	Detour::new_from_aob(
		(size, func),
		<span style="color:#75715e">// proc_inf contiene informaci√≥n esencial del proceso
</span><span style="color:#75715e"></span>		<span style="color:#f92672">&amp;</span>proc_inf,
        <span style="color:#75715e">// store_preferred_res es el puntero a mi shellcode, el cual est√°
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// escrito en assembly
</span><span style="color:#75715e"></span>		auto_cast<span style="color:#f92672">!</span>(store_preferred_res),
        <span style="color:#75715e">// En este caso el shellcode tiene un return, por lo cual no es
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// necesario inyectar un jmp back
</span><span style="color:#75715e"></span>		None,
		<span style="color:#ae81ff">12</span>,
        <span style="color:#75715e">// La direcci√≥n encontrada por el aob_scan no necesita de un offset.
</span><span style="color:#75715e"></span>		None,
	)
	.or(Err(<span style="color:#e6db74">&#34;Couldn&#39;t find store_pref_addr&#34;</span>))<span style="color:#f92672">?</span>
};

store_pref_detour.inject();
</code></pre></div><p>Lo genial de esto, es que usando las macros de Rust, podemos generar una
funci√≥n lambda que lo √∫nico que hace es intentar hacer match cuando el patr√≥n
se cumple (los <code>_</code> implican que puede haber cualquier byte en ese espacio), por
lo tanto no hay que parsear strings (I&rsquo;m looking at you, C++ üòâ).</p>
<h1 id="ciertos-usos-de-_memory-rs_">Ciertos usos de <em>memory-rs</em></h1>
<p>Bac√°n, te estoy vendiendo mi invento, pero, ¬øde qu√© sirve? bueno, aqu√≠ hay
ciertos ejemplos en los cuales mi librer√≠a me ha sido √∫til para acelerar el
proceso de creaci√≥n:</p>
<h2 id="rtti-dumper">rtti-dumper</h2>
<p>A veces los procesos contienen informaci√≥n en run-time de los tipos (Run Time
Type Information, RTTI), y a veces es pr√°ctico comenzar a mirar desde ah√≠ para
hacer ciertas b√∫squeda de objetos en memoria. Es por esto, que cre√© un
<a href="https://github.com/etra0/rtti_dumper"><code>rtti-dumper</code></a>, el cu√°l b√°sicamente
intenta encontrar las tablas de funciones virutales de objetos con informaci√≥n
en run-time. Usando Rust, pude abusar de la <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Fearless
Concurrency</a> para
crear algo multi-threaded, y sorprendentemente, el programa logra procesar ~60
GB/s! Gracias a que todo est√° en memoria, √©sta se puede revisar m√∫ltiples veces
y es extremadamente r√°pida, y no hay problemas al hacer acceso concurrente ya
que todo es read-only.</p>
<p>
  <img src="/assets/images/memory-rs/speed.png"  class="left"  />


<div style="text-align: center;">
		<em>Dumpeando las VFT de los RTTI contenidos en el Yakuza Kiwami 2, a ~60 GB/s</em>
</div>
</p>
<h2 id="red-dead-redemption-2-patch---range-removal">Red Dead Redemption 2 patch - range removal</h2>
<p>Red Dead Redemption 2 es un juego con vistas fant√°sticas, creo que hasta ahora,
no hay ning√∫n juego que se le compare. Debido a esto, en el servidor de Discord
que estoy, <a href="https://twitter.com/FransBouma">Frans Bouma</a> hab√≠a creado una Cheat
Table para Cheat Engine (nos volvemos a encontrar ‚ô•) donde implementaba el
range-removal del modo foto del juego (es decir, quitaba la limitaci√≥n de
alejamiento de la c√°mara) y adem√°s habilitaba la opci√≥n de usar hot-sampling
(b√°sicamente si la ventana escala, la resoluci√≥n tambi√©n lo hace, ideal para
tomar pantallazos de alta resoluci√≥n). Debido a esto, aprovech√© de darle un uso
a mi librer√≠a y pasar estas modificaciones a un parche (DLL) para que esta
inyecci√≥n se haga autom√°ticamente ya que el modo fodo lo ocupo bastante, y
usando la gran librer√≠a
<a href="https://github.com/ThirteenAG/Ultimate-ASI-Loader">Ultimate-ASI-Loader</a>, puedo
crear un parche que se cargue autom√°ticamente al abrir el juego.</p>
<p>
  <img src="/assets/images/memory-rs/RDR2.png"  class="left"  />


<div style="text-align: center;">
		<em>Foto del RDR2 por m√≠</em>
</div>
</p>
<h2 id="pel√≠culas-en-el-taskmgrhttpsgithubcometra0taskmgr-video"><a href="https://github.com/etra0/taskmgr-video">Pel√≠culas en el taskmgr</a></h2>
<p>Because, why not?</p>

  <img src="https://raw.githubusercontent.com/etra0/taskmgr-video/master/shrek.gif"  class="left"  style="width:100%"  />


<h1 id="ventajas-de-hacer-el-photo-mode-del-ylad-con-hacking-interno">Ventajas de hacer el Photo Mode del Y:LAD con hacking interno</h1>
<p>Para ir cerrando, d√©jame contarte de un par de ventajas que he obtenido gracias
al hacer el photo mode del Yakuza: Like A Dragon usando memory-rs con inyecci√≥n
interna:</p>
<h2 id="1-update-proof">1. Update-proof</h2>
<p>Como ya mencion√© previamente, usando la funci√≥n <code>aob_scan</code>, es mucho m√°s
probable que el parche sea update-proof debido a que los offsets pueden
cambiando, dicho y hecho, as√≠ fue, el ejecutable ha sido actualizado 2 veces (y
los offsets han cambiado seg√∫n mis logs) y el Free-Cam ha funcionado sin ning√∫n
problema. Si pasase eso con alguna de mis previas freecam, tendr√≠a que buscar
todo de nuevo con Cheat Engine, algo que es bastante consumidor de tiempo.</p>
<h2 id="2-rust-structs">2. Rust structs</h2>
<p>Oh boy, cuando se me ocurri√≥ esto, qued√© impresionado. Rust implementa un OOP
bastante √∫nico, el cu√°l b√°sicamente se resume en crear <code>struct</code>s, y estos
extenderlos a trav√©s de implementaciones, y tambi√©n existen <code>trait</code>s que se
pueden implementar sobre structs existentes (algo as√≠ parecido como a las
interfaces). ¬øPor qu√© te cuento esto? por lo siguiente. En la memoria del
juego, logr√© encontrar los valores esenciales del manejo de la c√°mara en el
mismo, y se me ocurri√≥ la brillante idea de castear esta informaci√≥n a un
<code>struct</code>, y luego extender ese <code>struct</code> con mis m√©todos para modificarlo, y
estoy demasiado orgulloso como qued√≥ este approach. Esto se ve algo as√≠:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// El repr(C) nos permite asegurar que el struct se compondr√° de forma similar
</span><span style="color:#75715e">// a como lo hacen los structs de C, con sus respectivos paddings
</span><span style="color:#75715e"></span><span style="color:#75715e">#[repr(C)]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GameCamera</span> {
    <span style="color:#75715e">// Por lo general siempre se ocupan vectores de tama√±o cuatro debido a las
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// facilidades que otorga SSE2.
</span><span style="color:#75715e"></span>    pos: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">4</span>],
    focus: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">4</span>],
    rot: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">4</span>],
    <span style="color:#75715e">// No conozco los valores que est√°n ac√°, y se pueden castear como un
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// arreglo m√°s alto, no ocupar√° m√°s memoria porque esto ya existe ;)
</span><span style="color:#75715e"></span>    padding_: [<span style="color:#66d9ef">f32</span>; <span style="color:#ae81ff">0x8</span>],
    fov: <span style="color:#66d9ef">f32</span>
}

<span style="color:#75715e">// Esto es lo genial, puedo extender el struct GameCamera desde Rust, y luego
</span><span style="color:#75715e">// aplicar estos m√©todos despu√©s de castear el puntero a mi struct personalizado,
</span><span style="color:#75715e">// bastante genial eh?
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> GameCamera {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">consume_input</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, input: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Input</span>) {
        <span style="color:#66d9ef">let</span> r_cam_x <span style="color:#f92672">=</span> self.focus[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> self.pos[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">let</span> r_cam_y <span style="color:#f92672">=</span> self.focus[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> self.pos[<span style="color:#ae81ff">1</span>];
        <span style="color:#66d9ef">let</span> r_cam_z <span style="color:#f92672">=</span> self.focus[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">-</span> self.pos[<span style="color:#ae81ff">2</span>];

        <span style="color:#66d9ef">let</span> (r_cam_x, r_cam_z, r_cam_y) <span style="color:#f92672">=</span>
            Camera::calc_new_focus_point(r_cam_x, r_cam_z, r_cam_y,
                input.delta_focus.<span style="color:#ae81ff">0</span>, input.delta_focus.<span style="color:#ae81ff">1</span>);

        self.pos[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> r_cam_x<span style="color:#f92672">*</span>input.delta_pos.<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span>
            input.delta_pos.<span style="color:#ae81ff">0</span><span style="color:#f92672">*</span>r_cam_z;
        self.pos[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> r_cam_y<span style="color:#f92672">*</span>input.delta_pos.<span style="color:#ae81ff">1</span>;

        self.pos[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> r_cam_z<span style="color:#f92672">*</span>input.delta_pos.<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span>
            input.delta_pos.<span style="color:#ae81ff">0</span><span style="color:#f92672">*</span>r_cam_x;

        self.focus[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> r_cam_x;
        self.focus[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> r_cam_y;
        self.focus[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> self.pos[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> r_cam_z;

        self.fov <span style="color:#f92672">=</span> input.fov;
    }
}

<span style="color:#75715e">// Tambi√©n pude implementar el trait Debug de mi propio struct, que en el fondo
</span><span style="color:#75715e">// imprim√≠a de forma m√°s bonita lo que ya estaba en memoria debido a las mismas
</span><span style="color:#75715e">// facilidades mencionadas arriba
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> std::fmt::Debug <span style="color:#66d9ef">for</span> GameCamera {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fmt</span>(<span style="color:#f92672">&amp;</span>self, f: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> std::fmt::Formatter<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;_</span><span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">std</span>::fmt::Result {
        <span style="color:#66d9ef">let</span> ptr <span style="color:#f92672">=</span> self <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">const</span> GameCamera <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
        f.debug_struct(<span style="color:#e6db74">&#34;GameCamera&#34;</span>)
            .field(<span style="color:#e6db74">&#34;self&#34;</span>, <span style="color:#f92672">&amp;</span>format_args<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:x}&#34;</span>, ptr))
            .field(<span style="color:#e6db74">&#34;pos&#34;</span>, <span style="color:#f92672">&amp;</span>self.pos)
            .field(<span style="color:#e6db74">&#34;focus&#34;</span>, <span style="color:#f92672">&amp;</span>self.focus)
            .field(<span style="color:#e6db74">&#34;rot&#34;</span>, <span style="color:#f92672">&amp;</span>self.rot)
            .field(<span style="color:#e6db74">&#34;fov&#34;</span>, <span style="color:#f92672">&amp;</span>self.fov)
            .finish()
    }
}

<span style="color:#75715e">// ... snip
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsafe</span> {
    <span style="color:#75715e">// casteamos el puntero a mi struct
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">let</span> gc <span style="color:#f92672">=</span> (g_camera_struct <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x80</span>) <span style="color:#66d9ef">as</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">mut</span> GameCamera;
    <span style="color:#75715e">// Usamos el m√©todo implementado INTERNAMENTE en mi DLL sobre valores que
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// ya estan en memoria dentro del juego
</span><span style="color:#75715e"></span>	(<span style="color:#f92672">*</span>gc).consume_input(<span style="color:#f92672">&amp;</span>input);

    <span style="color:#75715e">// Podemos imprimir los valores de la GameCamera usando el trait Debug
</span><span style="color:#75715e"></span>	println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, <span style="color:#f92672">*</span>gc);
}

</code></pre></div><p>¬øPor qu√© es posible esto? Bueno, los arreglos en memoria no son nada m√°s que
valores contiguos en la RAM, y las struct son arreglos contiguos que
&ldquo;conceptualmente&rdquo; est√°n agrupados, entonces basta con saber el tama√±o de estos
objetos y se pueden castear a cualquier struct que tenga un formato parecido
(por ejemplo, podr√≠a usar <code>u32</code> en vez de <code>f32</code>, ya que tienen el mismo tama√±o,
pero los valores no tendr√≠an sentido üòõ). ¬øBastante cool eh?</p>
<h2 id="3-compatibilidad-con-steam-y-ms-store-version">3. Compatibilidad con Steam y MS Store version</h2>
<p>Las freecam anteriores solo eran compatibles con la versi√≥n de steam (y si esta
se actualiza, gg), en cambio esta, al usar <code>scan_aob</code>, y patrones seleccionados
cuidadosamente (por ejemplo los <code>jmp</code> y los <code>call</code> se les removieron los
offsets), es posible encontrar todas las funciones a modificar
independientemente de la versi√≥n que est√©s ejecutando.</p>
<h1 id="finalizando">Finalizando</h1>
<p>En fin, esta nota fue un v√≥mito bastante rato, en conclusi√≥n, no me arrepiento
de haber comenzado a hacer inyecci√≥n interna, todo se hace m√°s entretenido, los
punteros son mucho m√°s divertido de lo que pensaba y la memoria es solo un
constructo social (heh). Si es que llegaste hasta ac√°, bac√°n, si te interesa
este t√≥pico, siempre me puedes encontrar en discord como etra#1337 o en
twitter como <a href="https://twitter.com/etra0">etra0</a> (En facebook no soy muy
activo).</p>

    </div>
    


    
      
    

    </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a href="/" class="logo" style="text-decoration: none;">
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367"/>
</svg>
</span>
    <span class="logo__text">Sebasti√°n Aedo&#39;s blog</span>
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span>¬© 2020 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span>
        <span>Theme created by <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span>
      </div>
    
  </div>
</footer>

<script src="https://etra0.github.io/assets/main.js"></script>
<script src="https://etra0.github.io/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
